\subsection{Existing Solutions}

% add a section discussing existing solutions and why there needs to be a new one.
% table of comparison of existing solutions, why this solution is better than existing solutions.

\begin{center}
\begin{tabular}{ |p{5.25cm}|p{5.25cm}|p{5.25cm}|  }
\hline
\multicolumn{3}{|c|}{Existing static analysis \& reverse engineering tools} \\
\hline
Tool name & Advantages & Drawbacks \\
\hline

% JTool
JTool & & \\
& - Mach-O parser and extensive analysis options & - Poorly formatted output \\
& - Kernel cache parser & - No longer actively developed \\
& - Code signing info parser & - Missing handling for firmware files such as iBoot, SEP or Device Tree \\
& - Kernel cache kext extracting and kernel decompression & \\
& - Dyld shared cache parser & \\
& - ARM64 disassembler (via LLVM API) & \\

\hline

% OTool
OTool & & \\
& - Extensive Mach-O parser & - Extremely muddled and confusing output \\
& - ARM64 \& x86\_64 disassembler (via LLVM or OTool API) & - Updates depend on macOS version \\
& - Shipped with Xcode & \\

\hline

% Objdump

Objdump & & \\
& - Feature-rich command line disassembler (ARM64 \& x86\_64) & - Can only disassemble Object files, no support for working with plain binaries. \\
& & - Primarily a disassembler, not a Mach-O parser \\
& & - Updates depend on macOS version \\

\hline

% IDA64

IDA64 & & \\
& - Professional disassembler and decompiler & - Expensive \\
& - Interactive GUI & - Overkill for small tasks such as disassembling a single function \\
& - Support for dozens of architectures, including ARM64 and x86\_64 & \\

\hline
\end{tabular}
\end{center}
\begin{center}
	\caption{\textbf{Figure 1:} Comparison table of currently available tools for static analysis and reverse engineering of iOS and macOS firmware files.}
\end{center}

There are already a few existing applications that provide the required tools for analysing and reverse engineering iOS and macOS firmware files, and they each have their own advantages and drawbacks. This is outlined in \textbf{Figure 1}.

My aim is for the HTool project to match the functionality of JTool, which itself absorbs features from \texttt{otool(1)}, and other Xcode/LLVM developer tools such as \texttt{dyldinfo(1)}, \texttt{nm(1)}, \texttt{strings(1)}, \texttt{codesign(1)} and \texttt{llvm-objdump(1)}. 

The Xcode developer tools are numerous and often confusing to use. While JTool solved this by combining most of their features into a single tool, the issue remains of often a non-user friendly output. See examples of OTool and JTool output in \textbf{Figure 2} and \textbf{Figure 3}.

\begin{verbatim}
$ otool -h -l /bin/ls
Mach header
      magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
 0xfeedfacf 16777228          2  0x80           2    19       1728 0x00200085
Load command 0
      cmd LC_SEGMENT_64
  cmdsize 72
  segname __PAGEZERO
   vmaddr 0x0000000000000000
   vmsize 0x0000000100000000
  fileoff 0
 filesize 0
  maxprot 0x00000000
 initprot 0x00000000
   nsects 0
    flags 0x0
Load command 1
      cmd LC_SEGMENT_64
  cmdsize 472
  segname __TEXT
   vmaddr 0x0000000100000000
   vmsize 0x0000000000008000
  fileoff 0
 filesize 32768
  maxprot 0x00000005
 initprot 0x00000005
   nsects 5
    flags 0x0    ...
\end{verbatim}
\begin{center}
	\caption{\textbf{Figure 2:} Output of OTool, printing the header (-h) and load commands (-l) of a given binary.}
\end{center}

\begin{verbatim}
$ jtool -h -l /bin/ls
Magic:	64-bit Mach-O
Type:	executable
CPU:	x86_64
Cmds:	19
size:	1816 bytes
Flags:	0x200085

LC 00: LC_SEGMENT_64          Mem: 0x000000000-0x100000000      __PAGEZERO
LC 01: LC_SEGMENT_64          Mem: 0x100000000-0x100005000      __TEXT
	Mem: 0x100004430-0x100004604            __TEXT.__stubs  (Symbol Stubs)
	Mem: 0x100004430-0x100004604            __TEXT.__stubs  (Symbol Stubs)
	Mem: 0x100004920-0x100004b10            __TEXT.__const  
	Mem: 0x100004b10-0x100004f66            __TEXT.__cstring        (C-String Literals)               
	Mem: 0x100004430-0x100004604            __TEXT.__stubs  (Symbol Stubs)
LC 02: LC_SEGMENT_64          Mem: 0x100005000-0x100006000      __DATA
    ...
\end{verbatim}
\begin{center}
	\caption{\textbf{Figure 3:} Output of JTool, printing the header (-h) and load commands (-l) of a given binary.}
\end{center}

Along with this, JTool does not have any built-in options for handling other firmware files such as SecureROM bins, iBoot, DeviceTree, SEP, SEPOS, and others. There is no version or device detections for binaries, something that would be a useful feature.

















